*****************************************************HARI OHM***********************************************************

Last Stopped:

i. Monolith and Microservice Architecture:
    A. Monolith Architecture:

        1. Earlier Architecture made using Monolith.
        2. Under single project, API, UI, JSP, AUTH, DB, SMS written in same service.
            a. Even if need to change a color, you need to compile and build this whole project.

    B. Microservice Architecture: (Uber)

        1. We have different service for different job.
        2. For e.g. Now we have a service for followings:
            a. Backend - seprate service
            b. UI - 
            c. Auth - 
            d. SMS - 
            e. Email Notification - 
        3. All these services combine to form a big app - This is known as separation of concerns.
        4. All these services talk to each other depending upon the use cases - This is known as separation of concerns.(Single responsibility Principle)
    
    C. Till now we are using Swiggy API data, now we are going to fetch data dynamically from api and using it dynamically

        1. Two ways to fetch the data from API:

            a. As soon as our page loads --> we can make API call (wait for data to come) --> Then we render the UI.

            React Approach:
            b. As soon as page loads --> we'll render the UI(whatever is there i.e. skeleton form) --> 
                Now we'll make an API call --> as soon as get the data we'll render the UI

            --> 2nd one will give you best UX.

    D. useEffect: (Normal function)

        1. Takes two arguments i.e. 

            a. first argument --> arrow function(callback function) --> useEffect(() => {})
            b. second argument --> dependency array --> useEffect(() => {}, [dependency])

        2. callback function will be called --> after your component renders.

        3. Conclusion:

            useEffect(() => {
                console.log("useEffect called!)     // called 2nd
            }, [])


            console.log("Body rendered")    // called 1st

        Note: Now how code is executed,
                whole code is rendered first --> when useEffect line occurs it stores the callback --> and when retrun function is rendered --> then after calls the callback function

        Note: fetch() --> is provided by browsers/js engine had it

Note: You'll notice until restaurant API loads, there is a blank page, 
        so we applied a simple loading..., but is it industry standard, no then what's the solution
        The solution is shimmerUI.

ii. Shimmer UI: 

    a. Shimmer UI - It's like loading fake page untill we get the actual data from API.
                    Created a file Shimmer.js
        
    b. Conditional Rendering - 
          if(listofRestaurants.length === 0){
                return <Shimmer />
            }

iii. Understanding of useState and useEffect using Login and Logout button:

    a. Using normal let variable example given in - Header.js
    b. Ans why we need state variable like useState and useEffect is also given in Header.js
    c. Simple explanation - When you use simple js variable using like let const 
                            and in given example when you click on login button, it is updating
                            btnName but not rendering the actual UI as there is nothing to refresh
                            the actual UI.
                            Hence, we need useState

    Doubt: When login state changes, will it re-render the whole Header.js or just that line of button ?
    Answer: It will render the complete Header.js once again i.e. will trigger the complete Header function in addition to updated state variable.

    Doubt: Tell me how can you update the const variable again isn't against the javascript rules using useState variable?
    Answer: Whenever you update the useState variable using useState, it will re-render the whole component
            and when whole js file refreshes, the variable to which you have set value becomes new after refreshes and hence not violating js rules.

    d. Every time login/logout button is clicked, reconciliation process happens i.e.
        React compares old virtual DOM of header and new virtual of DOM, and finds out that only button changed,
        So, in HTML , React will update only the button and everything remains intact.
        In simple language, on click of login/logout, Header component is rendered again and again i.e. 
        Header function is called again and again, and only the button state is updated.

iv. Search Functionality:

    Step1:
        a. Take input type HTML
            <input type="text" className="search-box" value={searchText} onChange={(e) => setSearchText(e.target.value)}/>
                    To get value in input, need to bind with local state of react
            value: it is bind to the serachText of useState
                    When you are changing the value, but it is bind to searchText of useState, hence will not change
                    Now when you are typing in input box nothing is happening, why ?
            onChange: To change the searchText, onChange handler is required
                    onChange will change the searchText variable, and react re-renders the component
                    means on every key press in input field whole component i.e. Body.js component is getting re-rendered
                    Whenever you are typing something it is calling onChange method and onChange method is taking this 
                    target value and updating the local state variable searchText and then react is rendering Body.js
                    that many times.But best part is React is triggering the reconciliation cycle and it is comparing
                    old virtual DOM with new virtual DOM.
                    We can say that React is re-rendering the whole body component but it only updating input box value insside the DOM

        b. Take useState for searchText:
            const [searchText, setSearchText] = useState('')

        c. Take useState for filteredRestaurant:
            const [filteredRestaurant, setFilteredRestaurant] = useState([])

        d. Take button onClick of which filtered resturants will be shown corresponding to searched input
            <button onClick={() => {
                const filteredRestaurant = listofRestaurants.filter((res) => {
                return res?.info?.name.toLowerCase().includes(searchText.toLowerCase())
                });
                setFilteredRestaurant(filteredRestaurant)
            }}>Search</button>
              // There is a problem with this for first time search is working and second time it is not (--11:16 )
              // Reason: When you are searching for first time, it is searching out of all items of restaurant.
              // But when searching for second time, it is searching out of those items previously searched as now they are 
              // are present in list of restuarants not the complete list of resturants
              // simple solution is to create another state variable for filteredListOfRestuarants
        
        c. Instead of mapping complete listofRestaurants, map the filteredListOfRestuarants:
            {filteredRestaurant?.map((restaurant) => (
                <RestaurantCard
                    key={restaurant?.info?.id}
                    resData={restaurant}
                />
            ))}
        


            

    